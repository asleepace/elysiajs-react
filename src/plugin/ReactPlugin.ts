import { unlink } from "node:fs/promises";
import { template } from "../utils/template";
import { findImports } from "../utils/findImports";
import { findComponentSource } from "../utils/findComponentSource";
import { createClientSideJS } from "../utils/createClientSideJS";
import { writeToStream } from "../utils/writeToStream";

export type ReactPluginConfig = {
  tempDir?: string;
  waitForStream?: boolean;
  publicPath?: string;
  verbose?: boolean;
};

export type ReactPluginTemplate = (
  importStatement: string,
  initialProps: any
) => string | Promise<string>;

export class ReactPlugin {
  /**
   * Default configuration for the ReactPlugin.
   */
  static defaultConfig = {
    waitForStream: true,
    publicPath: "public",
    tempDir: "src",
    verbose: false,
  } as const;

  /**
   * Import statements which are extracted from the `Bun.main` file,
   * used to extract the source file of the component.
   */
  public sources: string[] = [];
  /**
   * An array of client side js files that are generated by the plugin,
   * ideally these should be deleted when the plugin is stopped / started.
   */
  public clients: string[] = [];

  /**
   * The template function that generates the client side js file, this
   * can be overridden by the user to customize the client side js file.
   */
  public template: ReactPluginTemplate = template;

  constructor(public config: ReactPluginConfig) {}

  /**
   * Set the path to your public directory, this is where the client side
   * js files will be saved. Usually this will be the same as your `publicPath`
   * in your `staticPlugin` configuration.
   */
  set publicPath(publicPath: string) {
    if (this.isVerbose)
      console.log("[reactPlugin] setting publicPath:", publicPath);
    this.config.publicPath = publicPath;
  }

  get isVerbose() {
    return this.config.verbose || ReactPlugin.defaultConfig.verbose;
  }

  get publicPath() {
    return this.config.publicPath || ReactPlugin.defaultConfig.publicPath;
  }

  get tempDir() {
    return this.config.tempDir || ReactPlugin.defaultConfig.tempDir;
  }

  get waitForStream() {
    return this.config.waitForStream || ReactPlugin.defaultConfig.waitForStream;
  }

  public isReact(response: any): response is React.ReactElement {
    return (
      response &&
      "$$typeof" in response &&
      response.$$typeof === Symbol.for("react.element")
    );
  }

  public async sourceFiles(main: string) {
    if (this.isVerbose)
      console.log("[reactPlugin] finding source files:", main);
    const sources = await findImports(main);
    if (this.isVerbose)
      console.log("[reactPlugin] found source files:", sources);
    this.sources = [...sources];
  }

  public async deleteClients() {
    if (this.isVerbose)
      console.log("[reactPlugin] deleting all clients:", this.clients);
    return Promise.all(this.clients.map(unlink));
  }

  public saveClient(publicFilePath: string) {
    if (this.isVerbose)
      console.log("[reactPlugin] saving client:", publicFilePath);
    this.clients.push(publicFilePath);
  }

  public findClient(fileName: string): string | undefined {
    const found = this.clients.find((c) => c.includes(fileName));
    if (this.isVerbose)
      console.log(
        found
          ? `[reactPlugin] found client: ${found}`
          : `[reactPlugin] client not found: ${fileName}`
      );
    return found;
  }

  public async serverSideRender(
    component: React.ReactElement
  ): Promise<Response> {
    // extract the component name and import statement
    const importStatement = await findComponentSource({
      sources: this.sources,
      component,
    });

    // create the client side js file
    const clientSideJS = await createClientSideJS({
      importStatement,
      publicPath: this.publicPath,
      clients: this.clients,
      tempDir: this.tempDir,
    });

    // write the component to a stream
    const output = await writeToStream({
      waitForStream: this.waitForStream,
      clientSideJS,
      component,
    });

    // output the stream
    return new Response(output, {
      headers: {
        "Content-Type": "text/html; charset=utf-8",
      },
    });
  }
}
